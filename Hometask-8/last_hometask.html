<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script>
                                // до момента выполнения кода переменная а принадлежит глобальному объекту window со значением undefined. 
       if (!('a' in window)) { // Затем проверяется пременная a в объекте window ('a' in window), 
        var a = 1; // и она же локально задается переменной 'a' в глобальном объекте window (из var a получается window.a и переменной присваивается значение 1).
        }
        alert(a); // Но т.к. условие if проверяет НЕ 'a' in window, то значение остается тем, которое было изначально, т.е. undefined
        

        var b = function a(x) { // это именованное функциональное выражение
            x && a(--x); // внутри выполняется рекурсия: если вызвать функцию и задать х числовое значение, то функция будет вызывать саму себя, пока не станет false (х = 0)
        };
        alert(a); // имя именованного функционального выражения доступно только внутри самой функции. Снаружи его не видно, выдает ошибку


        function a(x) { // объявлена функция и переопредена переменная а (объявленная ниже без определения)
            return x * 2;
        }
        var a; // объявлена глобальная переменная со значением undefined (если бы переменная бала определена тут значением, например var a = 2, то алерт выдавал бы 2)
        alert(a()); // в алерте получаем присвоенное переменной а значение function a(x) {return x * 2}
        

        function b(x, y, a) { // объявляем функцию с параметрами
            arguments[2] = 10; // объект arguments схож с массивом и содержит в себе параметры функции. Массив с индекстом 2 - это третий по счету параметр, т.е. а присваиватся значение 10
            alert(a); // выводим алертом а со значением 10
        }
        b(1, 2, 3); // аргументы передаются в функцию, параметру а присваеивается значение 3, но arguments в теле функции переопределяет значение для а 
   

        // по поводу последнего примера затруднилась и нашла иформацию, что
        // в современном стандарте call/apply передают this «как есть»,
        // а в старом, без use strict, при указании первого аргумента null или undefined в call/apply, функция получает this = window

        // что означает "современный стандарт"? почему моя актуальная версия хрома все равно выдает window "по-старинке"?
        
        function a() {
            alert(this); // алерт выводит window
        }
        a.call(null);

    </script>
</head>
<body>
   
</body>
</html>